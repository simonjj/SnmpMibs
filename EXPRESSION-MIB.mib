-- *****************************************************************
-- Disman Expression MIB
--
-- July 1997, Sandra C. Durham
--
-- Copyright (c) 1997, 1998 by cisco Systems, Inc.
-- All rights reserved.
-- *****************************************************************
--
-- This mib was extracted from the first draft of the expression mib
-- (no draft-foo.txt available yet)



EXPRESSION-MIB DEFINITIONS ::= BEGIN

IMPORTS
    MODULE-IDENTITY, OBJECT-TYPE,
    Integer32, Gauge32,
    Counter32, Counter64, IpAddress	FROM SNMPv2-SMI
    TEXTUAL-CONVENTION, RowStatus,TruthValue,
    TimeStamp, DisplayString		FROM SNMPv2-TC
    ciscoExperiment			FROM CISCO-SMI
    Unsigned32				FROM CISCO-TC
    OwnerString				FROM IF-MIB
    sysUpTime				FROM RFC1213-MIB
    MODULE-COMPLIANCE, OBJECT-GROUP	FROM SNMPv2-CONF;

expressionMIB MODULE-IDENTITY
    LAST-UPDATED "9802251700Z"
    ORGANIZATION "IETF Distributed Management Working Group"
    CONTACT-INFO "Bob Stewart
                  Cisco Systems, Inc.
                  170 West Tasman Drive,
                  San Jose CA 95134-1706.
                  Phone: +1 408 526 4527
                  Email: bstewart@cisco.com"
    DESCRIPTION
	"The MIB module for defining expressions of MIB objects
	for network management purposes.

	This MIB is a work in progress of the IETF Distributed
	Management working group and is subject to change by
	that body."
    ::= { ciscoExperiment 22 }

ExpressionName ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
	"An identification for an expression.  An ExpressionName
	corresponds one-to-one to an ExpressionIndex.

	This identification of an expression is subject to change
	only by administrative request."
    SYNTAX      DisplayString (SIZE (1..64))

ExpressionIndex ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
	"An integer shorthand identification for an expression.
	An ExpressionIndex corresponds one-to-one to an
	ExpressionName.

	Once assigned an ExpressionIndex may not be changed."
    SYNTAX      Unsigned32 (1..4294967295)

ExpressionIndexOrZero ::= TEXTUAL-CONVENTION
    STATUS      current
    DESCRIPTION
	"Either an ExpressionIndex or zero.  The meaning of zero
	 depends on the DESCRIPTION of the object."
    SYNTAX      Unsigned32 (0..4294967295)


expressionMIBObjects OBJECT IDENTIFIER ::= { expressionMIB 1 }

expResource	OBJECT IDENTIFIER ::= { expressionMIBObjects 1 }
expNames	OBJECT IDENTIFIER ::= { expressionMIBObjects 2 }
expDefine	OBJECT IDENTIFIER ::= { expressionMIBObjects 3 }
expValue	OBJECT IDENTIFIER ::= { expressionMIBObjects 4 }


--
-- Wildcarding Example
--
-- This example refers to tables and objects defined below.  It may well
-- make more sense after reading those definitions.
--
-- An expression may use wildcarded MIB objects that result in multiple
-- values for the expression.  To specify a wildcarded MIB object a
-- management application leaves off part or all of the instance portion
-- of the object identifier, and sets expObjectWildcard to true(1) for that
-- object.  For our example we'll use a counter of total blessings
-- from a table of people.  Another table, indexed by town and person 
-- has blessings just from that town.
--
-- So the index clauses are:
--
--     personEntry OBJECT-TYPE
--     ...
--     INDEX { personIndex }
--
-- And:
--
--     townPersonEntry OBJECT-TYPE
--     ...
--     INDEX { townIndex, personIndex }
--
-- In our friendly application we may have entered our expression as:
--
--     100 * townPersonBlessings.976.* / personBlessings.*
--
-- What goes in expExpression is:
--
--     100*$1/$2
--
-- For example purposes we'll use some slightly far-fetched OIDs, but the
-- weirdity won't matter.  The People MIB is 1.3.6.1.99.7 and the Town MIB
-- is 1.3.6.1.99.11, so for our two counters the OIDs are:
--
--     personBlessings	1.3.6.1.99.7.1.3.1.4
--     townPersonBlessings	1.3.6.1.99.11.1.2.1.9
--
-- The rule for wildcards is that all the wildcarded parts have to match
-- exactly.  In this case that means we have to hardwire the town and only
-- the personIndex can be wildcarded.  So our values for expObjectID are:
--
--     1.3.6.1.99.7.1.3.1.4
--     1.3.6.1.99.11.1.2.1.9.976
--
-- We're hardwired to townIndex 976 and personIndex is allowed to vary.
--
-- The value of expExpressionPrefix can be either of those two counter OIDs
-- (including the instance fragment in the second case), since either of
-- them takes you to a MIB definition where you can look at the INDEX
-- clause and figure out what's been left off.  What's been left off
-- doesn't have to work out to be the same object, but it does have to work
-- out to be the same values (semantics) for the result to make sense.
-- Note that the agent can not typically check such semantics and if given
-- nonsense will return nonsense.
--
-- If we have people numbered 6, 19, and 42 in town number 976, the
-- successive values of expValueInstance will be:
--
--     0.0.6
--     0.0.19
--     0.0.42
--
-- So there will be three values in expValueTable, with those OIDs as the
-- expValueInstance part of their indexing.
--


--
-- Resource Control
--

expResourceDeltaMinimum OBJECT-TYPE
    SYNTAX      Integer32 (-1 | 1..600)
    UNITS       "seconds"
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"The minimum expExpressionDeltaInterval this system will
	accept.  A system may use the larger values of this minimum
	to lessen the impact of constantly computing deltas.

	The value -1 indicates this system will not accept
	deltaValue as a value for expObjectSampleType.

	Unless explicitly resource limited, a system's value for
	this object should be 1.

	Changing this value will not invalidate an existing setting
	of expObjectSampleType."
    ::= { expResource 1 }

expResourceDeltaWildcardInstanceMaximum OBJECT-TYPE
    SYNTAX      Unsigned32
    UNITS       "instances"
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"The maximum number of dynamic instance entries this system
	will support for wildcarded delta objects in expressions.
	These are the entries that maintain state, one for each
	instance of each deltaValue object for each value of an
	expression.

	A value of 0 indicates no preset limit, that is, the limit
	is dynamic based on system operation and resources.

	Unless explicitly resource limited, a system's value for
	this object should be 0.

	Changing this value will not eliminate or inhibit existing delta
	wildcard instance objects but will prevent the creation of more
	such objects."
    ::= { expResource 2 }

expResourceDeltaWildcardInstances OBJECT-TYPE
    SYNTAX      Gauge32
    UNITS       "instances"
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The number of currently active instance entries as
	defined for expResourceDeltaWildcardInstanceMaximum."
    ::= { expResource 3 }

expResourceDeltaWildcardInstancesHigh OBJECT-TYPE
    SYNTAX      Gauge32
    UNITS       "instances"
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The highest value of expResourceDeltaWildcardInstances
	that has occurred since initialization of the management
	system."
    ::= { expResource 4 }

expResourceDeltaWildcardInstanceResourceLacks OBJECT-TYPE
    SYNTAX      Counter32
    UNITS       "instances"
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The number of times this system could not evaluate an expression
	because that would have created a value instance in excess of
	expResourceDeltaWildcardInstanceMaximum."
    ::= { expResource 5 }


--
-- Naming & Creation
--

expNameLastChange OBJECT-TYPE
    SYNTAX      TimeStamp
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value of sysUpTime the last time an expression was
	created or deleted or had its name changed using
	expExpressionName."
    ::= { expNames 1 }

expNameHighestIndex OBJECT-TYPE
    SYNTAX      ExpressionIndexOrZero
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The highest value of ExpressionIndex ever assigned on
	this system.  Preferrably this value is preserved across
	system reboots.  A managed system that is unable to
	store expressions across reboots need not preserve this
	value across reboots.

	If all expression-creating applications cooperate, they
	may use this to avoid reusing an ExpressionIndex.  To
	do so, attempt creation of a new entry with this
	value + 1 as the value of expExpressionIndex.

	Although reusing ExpressionIndexes could lead to an
	application receiving a misunderstood value, it is a
	matter of local management policy whether to reuse them."
    ::= { expNames 2 }

--
-- Name Creation Table
--

expNameTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF ExpNameEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"A table of expression names, for creating and deleting
	expressions."
    ::= { expNames 3 }

expNameEntry OBJECT-TYPE
    SYNTAX      ExpNameEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"Information about a single expression.  New expressions
	can be created using expNameStatus.

	To create an expression first create the named entry in this
	table.  Then use expExpressionIndex to populate
	expExpressionTable and expObjectTable.  For expression
	evaluation to succeed all related entries in expNameTable,
	expExpressionTable, and expObjectTable must be 'active'.  If
	these conditions are not met the corresponding values in
	expValue simply are not instantiated.

	Deleting an entry deletes all related entries in
	expExpressionTable and expObjectTable.

	Because of the relationships among the multiple tables
	for an expression (expNameTable, expExpressionTable,
	expObjectTable, and expValueTable) and the SNMP rules
	for independence in setting object values, it is
	necessary to do final error checking when an expression
	is evaluated, that is, when one of its instances in
	expValueTable is read.  Earlier checking need not be
	done and an implementation may not impose any ordering
	on the creation of objects related to an expression other
	than to require values for expName and expExpressionIndex
	before any other related objects can be created.

	To maintain security of MIB information, when creating a new
	row in this table, the managed system must record the security
	credentials of the requester.  If the subsequent expression
	includes objects with expObjectSampleType 'deltaValue' the
	evaluation of that expression takes place under the security
	credentials of the creator of its expNameEntry."
    INDEX       { IMPLIED expName }
    ::= { expNameTable 1 }

ExpNameEntry ::= SEQUENCE {
    expName                     ExpressionName,
    expExpressionIndex          ExpressionIndex,
    expNameStatus               RowStatus
}

expName OBJECT-TYPE
    SYNTAX      ExpressionName
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"The name of the expression.  Choosing names with useful
	lexical ordering supports using GetNext or GetBulk to
	retrieve a useful subset of the table."
    ::= { expNameEntry 1 }

expExpressionIndex OBJECT-TYPE
    SYNTAX      ExpressionIndex
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The numeric identification of the expression.

	Applications may select this number in ascending numerical
	order by using expNameHighestIndex as a hint or may use any
	other acceptable, unused number.

	Once set this value may not be set to a different value."
    ::= { expNameEntry 2 }

expNameStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The control that allows creation/deletion of entries."
    ::= { expNameEntry 3 }

--
-- Definition
--
-- Expression Definition Table
--

expExpressionTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF ExpExpressionEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"A table of expression definitions."
    ::= { expDefine 1 }

expExpressionEntry OBJECT-TYPE
    SYNTAX      ExpExpressionEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"Information about a single expression.  An entry appears in
	this table when an entry is created in expNameTable.  Deleting
	that expNameTable entry automatically deletes this entry and its
	associated expObjectTable entries.

	Values of read-write objects in this table may be changed
	at any time."
    INDEX       { expExpressionIndex }
    ::= { expExpressionTable 1 }

ExpExpressionEntry ::= SEQUENCE {
    expExpressionName	         ExpressionName,
    expExpression                OCTET STRING,
    expExpressionValueType       INTEGER,
    expExpressionComment         DisplayString,
    expExpressionDeltaInterval   Integer32,
    expExpressionPrefix	         OBJECT IDENTIFIER,
    expExpressionErrors          Counter32,
    expExpressionErrorTime       TimeStamp,
    expExpressionErrorIndex      Integer32,
    expExpressionError           INTEGER,
    expExpressionInstance        OBJECT IDENTIFIER,
    expExpressionOwner           OwnerString
}

expExpressionName OBJECT-TYPE
    SYNTAX      ExpressionName
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"The unique name of the expression, the same as expName.

	Use this object to change the expression's name without
	changing its expExpressionIndex."
    ::= { expExpressionEntry 1 }

expExpression OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE (1..1024))
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"The expression to be evaluated.  This object is the same
	as a DisplayString (RFC 1903) except for its maximum length.

	Except for the variable names the expression is in ANSI C
	syntax.  Only the subset of ANSI C operators and functions
	listed here is allowed.

	Variables are expressed as a dollar sign ('$') and an
	integer that corresponds to an expObjectIndex.  An
	example of a valid expression is:

		($1-$5)*100

	Expressions may not be recursive, that is although an expression
	may use the results of another expression, it may not contain any
	variable that is directly or indirectly a result of its own
	evaluation.

	The only allowed operators are:

		( )
		- (unary)
		+ - * / %
		& | ^ << >> ~
		! && || == != > >= < <=

	Note the parentheses are included for parenthesizing the
	expression, not for casting data types.

	The only constant types defined are:

		int (32-bit signed)
		long (64-bit signed)
		unsigned int
		unsigned long
		hexadecimal
		character
		string
		oid

	The default type for a positive integer is int unless it is too
	large in which case it is long.

	All but oid are as defined for ANSI C.  Note that a
	hexadecimal constant may end up as a scalar or an array of
	8-bit integers.  A string constant is enclosed in double
	quotes and may contain back-slashed individual characters
	as in ANSI C.

	An oid constant comprises 32-bit, unsigned integers and at
	least one period, for example:

		0.
		.0
		1.3.6.1

	Integer-typed objects are treated as 32- or 64-bit, signed
	or unsigned integers, as appropriate.  The results of
	mixing them are as for ANSI C, including the type of the
	result.  Note that a 32-bit value is thus promoted to 64 bits
	only in an operation with a 64-bit value.  There is no
	provision for larger values to handle overflow.

	Relative to SNMP data types, a resulting value becomes
	unsigned when calculating it uses any unsigned value,
	including a counter.  To force the final value to be of
	data type counter the expression must explicitly use the
	counter32() or counter64() function (defined below).

	OCTET STRINGS and OBJECT IDENTIFIERs are treated as 1-based
	arrays of unsigned 8-bit integers and unsigned 32-bit
	integers, respectively.

	IpAddresses are treated as 32-bit, unsigned integers in
	network byte order, that is, the hex version of 255.0.0.0 is
	0xff000000.

	Conditional expressions result in a 32-bit, unsigned integer
	of value 0 for false or 1 for true. When an arbitrary value
	is used as a boolean 0 is false and non-zero is true.

	Rules for the resulting data type from an operation, based on the
	operator:

	For << and >> the result is the same as the left hand operand.

	For &&, ||, ==, !=, <, <=, >, and >= the result is always
	Unsigned32.

	For unary - the result is always Integer32.

	For +, -, *, /, %, &, |, and ^ the result is promoted according to
	the following rules, in order from most to least preferred:

		If left hand and right hand operands are the same type, use
		that.

		If either side is Counter64, use that.

		If either side is IpAddress, use that.

		If either side is TimeTicks, use that.

		If either side is Counter32, use that.

		Otherwise use Unsigned32.

	The following rules say what operators apply with what data types.
	Any combination not explicitly defined does not work.

	For all operators any of the following can be the left hand or
	right hand operand: Integer32, Counter32, Unsigned32, Counter64.

	The operators +, -, *, /, %, <, <=, >, and >= also work with
	TimeTicks.

	The operators &, |, and ^ also work with IpAddress.

	The operators << and >> also work with IpAddress but only as the
	left hand operand.

	The + operator performs a concatenation of two OCTET STRINGs or two
	OBJECT IDENTIFIERs.

	The operators &, | perform bitwise operations on OCTET STRINGs.  If
	the OCTET STRING happens to be a DisplayString the results may be
	meaningless, but the agent system does not check this as some such
	systems do not have this information.

	The operators << and >> perform bitwise operations on OCTET STRINGs
	appearing as the left hand operand.

	The only functions defined are:

		counter32
		counter64
		arraySection
		stringBegins
		stringEnds
		stringContains
		oidBegins
		oidEnds
		oidContains
		sum
		exists

	The following function definitions indicate their by naming the
	data type of the parameter in the parameter's position in the
	parameter list.  The parameter must be of the type indicated and
	generally may be a constant, a MIB object, a function, or an
	expression.

	counter32(integer) - wrapped around an integer value counter32
	forces Counter32 as a data type.

	counter64(integer) - similar to counter32 except that the
	resulting data type is 'counter64'.

	arraySection(array, integer, integer) - selects a piece of an array
	(i.e. part of an OCTET STRING or OBJECT IDENTIFIER).  The integer
	arguments are in the range 0 to 4,294,967,295.  The first is an
	initial array index (1-based) and the second is an ending array
	index.  A value of 0 indicates first or last element, respectively.
	If the first element is larger than the array length the result is
	0 length.  If the second integer is less than or equal to the
	first, the result is 0 length.  If the second is larger than the
	array length it indicates last element.

	stringBegins/Ends/Contains(octetString, octetString) - looks
	for the second string (which can be a string constant) in the
	first and returns the 1-based index where the match began.  A
	return value of 0 indicates no match (i.e. boolean false).

	oidBegins/Ends/Contains(oid, oid) - looks for the second OID
	(which can be an OID constant) in the first and returns the
	the 1-based index where the match began.  A return value of 0
	indicates no match (i.e. boolean false).

	sum(integerObject*) - sums all availiable values of the wildcarded
	integer object, resulting in an integer scalar.  Must be used
	with caution as it wraps on overflow with no notification.

	exists(anyTypeObject) - verifies the object instance exists. A
	return value of 0 indicates NoSuchInstance (i.e. boolean false)."
    ::= { expExpressionEntry 2 }

expExpressionValueType OBJECT-TYPE
    SYNTAX      INTEGER { counter32(1), unsignedOrGauge32(2),
                          timeTicks(3), integer32(4), ipAddress(5),
                          octetString(6), objectId(7), counter64(8) }
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"The type of the expression value.  One and only one of the value
	objects in expValueTable will be instantiated to match this type.

	If the result of the expression can not be made into this type,
	an invalidOperandType error will occur."
    DEFVAL      { counter32 }
    ::= { expExpressionEntry 3 }

expExpressionComment OBJECT-TYPE
    SYNTAX      DisplayString
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"A comment to explain the use or meaning of the expression."
    DEFVAL      { ''H }
    ::= { expExpressionEntry 4 }

expExpressionDeltaInterval OBJECT-TYPE
    SYNTAX      Integer32 (0..86400)
    UNITS       "seconds"
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"Sampling interval for objects in this expression with
	expObjectSampleType 'deltaValue'.

	This object is not instantiated if not applicable.

	A value of 0 indicates no automated sampling.  In this case
	the delta is the difference from the last time the expression
	was evaluated.  Note that this is subject to unpredictable
	delta times in the face of retries or multiple managers.

	A value greater than zero is the number of seconds between
	automated samples.

	Until the delta interval has expired once the delta for the
	object is effectively not instantiated and evaluating
	the expression has results as if the object itself were not
	instantiated.

	Note that delta values potentially consume large amounts of
	system CPU and memory.  Delta state and processing must
	continue constantly even if the expression is not being used.
	That is, the expression is being evaluated every delta interval,
	even if no application is reading those values.  For wildcarded
	objects this can be substantial overhead.

	Note that delta intervals, external expression value sampling
	intervals and delta intervals for expressions within other
	expressions can have unusual interactions as they are impossible
	to synchronize accurately.  In general one interval embedded
	below another must be enough shorter that the higher sample
	sees relatively smooth, predictable behavior."
    DEFVAL      { 0 }
    ::= { expExpressionEntry 5 }

expExpressionPrefix OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"An object prefix to assist an application in determining
	the instance indexing to use in expValueTable, relieving the
	application of the need to scan the expObjectTable to
	determine such a prefix.

	See expObjectTable for information on wildcarded objects.

	If the expValueInstance portion of the value OID may
	be treated as a scalar (that is, normally, 0) the value of
	expExpressionPrefix is zero length, that is, no OID at all.

	Otherwise expExpressionPrefix is the value of any wildcarded
	instance of expObjectID for the expression.  This is
	sufficient as the remainder, that is, the instance fragment
	relevant to instancing the values must be the same for all
	wildcarded objects in the expression."
    ::= { expExpressionEntry 6 }

expExpressionErrors OBJECT-TYPE
    SYNTAX      Counter32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The number of errors encountered while evaluating this
	expression.

	Note that an object in the expression not being accessible
	is not considered an error.  It is a legitimate condition
	that causes the corresponding expression value not to be
	instantiated."
    ::= { expExpressionEntry 7 }

expExpressionErrorTime OBJECT-TYPE
    SYNTAX      TimeStamp
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value of sysUpTime the last time an error caused a
	failure to evaluate this expression.

	This object is not instantiated if there have been no
	errors."
    ::= { expExpressionEntry 8 }

expExpressionErrorIndex OBJECT-TYPE
    SYNTAX      Integer32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The 1-based character index into expExpression for where
	the error occurred.  The value zero indicates irrelevance.

	This object is not instantiated if there have been no
	errors."
    ::= { expExpressionEntry 9 }

expExpressionError OBJECT-TYPE
    SYNTAX      INTEGER {
		invalidSyntax(1),
		undefinedObjectIndex(2),
		unrecognizedOperator(3),
		unrecognizedFunction(4),
		invalidOperandType(5),
		unmatchedParenthesis(6),
		tooManyWildcardValues(7),
		recursion(8),
		deltaTooShort(9),
		resourceUnavailable(10),
		divideByZero(11)
		}
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The error that occurred.  In the following explanations the
	expected timing of the error is in parentheses.  'S' means
	the error occurs on a Set request.  'E' means the error
	occurs on the attempt to evaluate the expression either due to
	Get from expValueTable or in ongoing delta processing.

	invalidSyntax		the value sent for expExpression is not
				valid Expression MIB expression syntax (S)
	undefinedObjectIndex	an object reference ($n) in expExpression
				does not have a matching instance in
				expObjectTable (E)
	unrecognizedOperator	the value sent for expExpression held an
				unrecognized operator (S)
	unrecognizedFunction	the value sent for expExpression held an
				unrecognized function name (S)
	invalidOperandType	an operand in expExpression is not the
				right type for the associated operator
				or result (SE)
	unmatchedParenthesis	the value sent for expExpression is not
				correctly parenthesized (S)
	tooManyWildcardValues	evaluating the expression exceeded the
				limit set by
				expResourceDeltaWildcardInstanceMaximum (E)
	recursion		through some chain of embedded expressions
				the expression invokes itself (E)
	deltaTooShort		the delta for the next evaluation passed
				before the system could evaluate the
				present sample (E)
	resourceUnavailable	some resource, typically dynamic memory,
				was unavailable (SE)
	divideByZero		an attempt to divide by zero occurred (E)

	For the errors that occur when the attempt is made to set
	expExpression Set request fails with the SNMP error code 'wrongValue'.
	Such failures refer to the most recent failure to Set
	expExpression, not to the present value of expExpression which
	must be either unset or syntactically correct.

	Errors that occur during evalutaion for a Get* operation return
	the SNMP error code 'genErr' except for 'tooManyWildcardValues'
	and 'resourceUnavailable' which return the SNMP error code
	'resourceUnavailable'.

	This object is not instantiated if there have been no
	errors."
    ::= { expExpressionEntry 10 }

expExpressionInstance OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The expValueInstance being evaluated when the error
	occurred.  A zero-length indicates irrelevance.

	This object is not instantiated if there have been no
	errors."
    ::= { expExpressionEntry 11 }

expExpressionOwner OBJECT-TYPE
    SYNTAX      OwnerString
    MAX-ACCESS  read-write
    STATUS      current
    DESCRIPTION
	"The entity that configured this entry and is therefore using the
	resources assigned to it."
    DEFVAL      { "" }
    ::= { expExpressionEntry 12 }

--
-- Object Table
--

expObjectTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF ExpObjectEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"A table of object definitions for each expExpression.

	Wildcarding instance IDs:

	It is legal to omit all or part of the instance portion for
	some or all of the objects in an expression. (See the
	DESCRIPTION of expObjectID for details.  However, note that
	if more than one object in the same expression is wildcarded
	in this way, they all must be objects where that portion of
	the instance is the same.  In other words, all objects may be
	in the same SEQUENCE or in different SEQUENCEs but with the
	same semantic index value (e.g., a value of ifIndex)
	for the wildcarded portion."
    ::= { expDefine 2 }

expObjectEntry OBJECT-TYPE
    SYNTAX      ExpObjectEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"Information about an object.  An application uses
	expObjectStatus to create entries in this table while
	in the process of defining an expression.

	Values of read-create objects in this table may be
	changed at any time."
    INDEX       { expExpressionIndex, expObjectIndex }
    ::= { expObjectTable 1 }

ExpObjectEntry ::= SEQUENCE {
    expObjectIndex                     Unsigned32,
    expObjectID                        OBJECT IDENTIFIER,
    expObjectIDWildcard                TruthValue,
    expObjectSampleType                INTEGER,
    expObjectDeltaDiscontinuityID      OBJECT IDENTIFIER,
    expObjectDiscontinuityIDWildcard   TruthValue,
    expObjectDiscontinuityIDType       INTEGER,
    expObjectConditional               OBJECT IDENTIFIER,
    expObjectConditionalWildcard       TruthValue,
    expObjectStatus                    RowStatus
}

expObjectIndex OBJECT-TYPE
    SYNTAX      Unsigned32 (1..4294967295)
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"Within an expression, a unique, numeric identification for an
	object.  Prefixed with a dollar sign ('$') this is used to
	reference the object in the corresponding expExpression."
    ::= { expObjectEntry 1 }

expObjectID OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The OBJECT IDENTIFIER (OID) of this object.  The OID may be
	fully qualified, meaning it includes a complete instance
	identifier part (e.g., ifInOctets.1 or sysUpTime.0), or it
	may not be fully qualified, meaning it may lack all or part
	of the instance identifier.  If the expObjectID is not fully
	qualified, then expObjectWildcard must be set to true(1).  
	The value of the expression will be multiple
	values, as if done for a GetNext sweep of the object.

	An object here may itself be the result of an expression but
	recursion is not allowed.

	NOTE:  The simplest implementations of this MIB may not allow
	wildcards."
    ::= { expObjectEntry 2 }

expObjectIDWildcard  OBJECT-TYPE
    SYNTAX      TruthValue
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
        "A true value indicates the expObjecID of this row is a wildcard
        object. False indicates that expObjectID is fully instanced.
        If all expObjectWildcard values for a given expression are FALSE,
        expExpressionPrefix will reflect a scalar object (ie will
        be 0.0).
 
        NOTE:  The simplest implementations of this MIB may not allow
        wildcards."
    DEFVAL      { false }
    ::= { expObjectEntry 3 }


expObjectSampleType OBJECT-TYPE
    SYNTAX      INTEGER { absoluteValue(1), deltaValue(2) }
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The method of sampling the selected variable.

	An 'absoluteValue' is simply the present value of the object.

	A 'deltaValue' is the present value minus the previous value,
	which was sampled expExpressionDeltaInterval seconds ago.
	This is intended primarily for use with SNMP counters, which are
	meaningless as an 'absoluteValue', but may be used with any
	integer-based value.

	When an expression contains both delta and absolute values
	the absolute values are obtained at the end of the delta
	period."
    DEFVAL      { absoluteValue }
    ::= { expObjectEntry 4 }

sysUpTimeInstance OBJECT IDENTIFIER ::= { sysUpTime 0 }

expObjectDeltaDiscontinuityID OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The OBJECT IDENTIFIER (OID) of a TimeTicks or TimeStamp object
	that indicates a discontinuity in the value at expObjectID.

	This object is not instantiated if expObject is not 'deltaValue'.

	The OID may be for a leaf object (e.g. sysUpTime.0) or may
	be wildcarded to match expObjectID.

	This object supports normal checking for a discontinuity in a
	counter.  Note that if this object does not point to sysUpTime
	discontinuity checking must still check sysUpTime for an overall
	discontinuity.

	If the object identified is not accessible no discontinuity
	check will be made."
    DEFVAL      { sysUpTimeInstance }
    ::= { expObjectEntry 5 }

expObjectDiscontinuityIDWildcard OBJECT-TYPE
     SYNTAX      TruthValue
     MAX-ACCESS  read-create
     STATUS      current
     DESCRIPTION
	"A true value indicates the expObjectDeltaDiscontinuityID of this
	row is a wildcard object.  False indicates that
	expObjectDeltaDiscontinuityID is fully instanced.

	This object is not instantiated if expObject is not 'deltaValue'.
 
	NOTE:  The simplest implementations of this MIB may not allow
	wildcards."
    DEFVAL      { false }
     ::= { expObjectEntry 6 }

expObjectDiscontinuityIDType OBJECT-TYPE
     SYNTAX      INTEGER { timeTicks(1), timeStamp(2) }
     MAX-ACCESS  read-create
     STATUS      current
     DESCRIPTION
	"The value 'timeTicks' indicates the expObjectDeltaDiscontinuityID
	of this row is of syntax TimeTicks.  The value 'timeStamp'
	indicates that expObjectDeltaDiscontinuityID is of syntax
	TimeStamp.

	This object is not instantiated if expObject is not 'deltaValue'."
    DEFVAL      { timeTicks }
     ::= { expObjectEntry 7 }

nullOID OBJECT IDENTIFIER ::= { 0 0 }

expObjectConditional OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The OBJECT IDENTIFIER (OID) of an object that overrides
	whether the instance of expObjectID is to be considered
	usable.  If the value of the object at expObjectConditional
	is 0 or not instantiated, the object at expObjectID is
	treated as if it is not instantiated.  In other words,
	expObjectConditional is a filter that controls whether or
	not to use the value at expObjectID.

	The OID may be for a leaf object (e.g. sysObjectID.0) or may be
	wildcarded to match expObjectID.  If expObject is wildcarded and
	expObjectID in the same row is not, the wild portion of
	expObjectConditional must match the wildcarding of the rest of the
	expression.  If no object in the expression is wildcarded but
	expObjectConditional is, use the lexically first instance (if any)
	of expObjectConditional.

	If the value of expObjectConditional is 0.0 operation is
	as if the value pointed to by expObjectConditional is a
	non-zero (true) value.

	Note that expObjectConditional can not trivially use an object of
	syntax TruthValue, since the underlying value is not 0 or 1."
    DEFVAL      { nullOID }
    ::= { expObjectEntry 8 }

 expObjectConditionalWildcard  OBJECT-TYPE
     SYNTAX      TruthValue
     MAX-ACCESS  read-create
     STATUS      current
     DESCRIPTION

	"A true value indicates the expObjectConditional of this row is a
	wildcard object. False indicates that expObjectConditional is fully
	instanced.
 
	NOTE: The simplest implementations of this MIB may not allow
	wildcards."
    DEFVAL      { false }
     ::= { expObjectEntry 9 }

expObjectStatus OBJECT-TYPE
    SYNTAX      RowStatus
    MAX-ACCESS  read-create
    STATUS      current
    DESCRIPTION
	"The control that allows creation/deletion of entries.

	Objects in this table may be changed while expObjectStatus
	is in any state."
    ::= { expObjectEntry 10 }

--
-- Expression Value Table
--

expValueTable OBJECT-TYPE
    SYNTAX      SEQUENCE OF ExpValueEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"A table of values from evaluated expressions."
    ::= { expValue 1 }

expValueEntry OBJECT-TYPE
    SYNTAX      ExpValueEntry
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"A single value from an evaluated expression.  For a given
	instance, only one 'Val' object in the conceptual row will
	be instantiated, that is, the one with the appropriate type
	for the value.  For values that contain no objects of 
	expObjectSampleType 'deltaValue', reading a value from the table
	causes the evaluation of the expression for that value.  For those
	that contain a 'deltaValue' the value read is as of the last
	delta interval.

	If in the attempt to evaluate the expression one or more
	of the necessary objects is not available, the corresponding
	entry in this table is effectively not instantiated.

	To maintain security of MIB information, expression evaluation
	must take place using security credentials for the implied
	Gets of the objects in the expression.  For expressions with
	no deltaValue those security credentials are the ones that
	came with the Get* for the value.  For expressions with a
	deltaValue the ongoing expression evaluation is under the
	security credentials of the creator of the corresponding
	expNameEntry."
    INDEX       { expExpressionIndex, IMPLIED expValueInstance }
    ::= { expValueTable 1 }

ExpValueEntry ::= SEQUENCE {
    expValueInstance          OBJECT IDENTIFIER,
    expValueCounter32Val      Counter32,
    expValueUnsigned32Val     Unsigned32,
    expValueInteger32Val      Integer32,
    expValueIpAddressVal      IpAddress,
    expValueOctetStringVal    OCTET STRING,
    expValueOidVal            OBJECT IDENTIFIER,
    expValueCounter64Val      Counter64
}

expValueInstance OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  not-accessible
    STATUS      current
    DESCRIPTION
	"The final instance portion of a value's OID according to
	the wildcarding in instances of expObjectID for the
	expression.  The prefix of this OID fragment is 0.0,
	leading to the following behavior.

	If there is no wildcarding, the value is 0.0.0.  In other
	words, there is one value which standing alone would have
	been a scalar with a 0 at the end of its OID.

	If there is wildcarding, the value is 0.0 followed by
	a value that the wildcard can take, thus defining one value
	instance for each real, possible value of the wildcard.
	So, for example, if the wildcard worked out to be an ifIndex,
	there is an expValueInstance for each applicable ifIndex."
    ::= { expValueEntry 1 }

expValueCounter32Val OBJECT-TYPE
    SYNTAX      Counter32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'counter32'."
    ::= { expValueEntry 2 }

expValueUnsigned32Val OBJECT-TYPE
    SYNTAX      Unsigned32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'unsignedOrGauge32'
	or 'timeTicks'."
    ::= { expValueEntry 3 }

expValueInteger32Val OBJECT-TYPE
    SYNTAX      Integer32
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'integer32'."
    ::= { expValueEntry 4 }

expValueIpAddressVal OBJECT-TYPE
    SYNTAX      IpAddress
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'ipAddress'."
    ::= { expValueEntry 5 }

expValueOctetStringVal OBJECT-TYPE
    SYNTAX      OCTET STRING (SIZE (0..65536))
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'octetString'."
    ::= { expValueEntry 6 }

expValueOidVal OBJECT-TYPE
    SYNTAX      OBJECT IDENTIFIER
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'objectId'."
    ::= { expValueEntry 7 }

expValueCounter64Val OBJECT-TYPE
    SYNTAX      Counter64
    MAX-ACCESS  read-only
    STATUS      current
    DESCRIPTION
	"The value when expExpressionValueType is 'counter64'."
    ::= { expValueEntry 8 }

--
-- Conformance
--

expressionMIBConformance OBJECT IDENTIFIER ::= { expressionMIB 3 }
expressionMIBCompliances OBJECT IDENTIFIER ::= { expressionMIBConformance 1 }
expressionMIBGroups      OBJECT IDENTIFIER ::= { expressionMIBConformance 2 }

-- Compliance

expressionMIBCompliance MODULE-COMPLIANCE
	STATUS current
	DESCRIPTION
		"The compliance statement for entities which implement
		the Expression MIB."
	MODULE	-- this module
		MANDATORY-GROUPS {
			expressionResourceGroup,
			expressionDefinitionGroup,
			expressionValueGroup
		}

	OBJECT         expResourceDeltaMinimum
	SYNTAX         Integer32 (-1 | 60..600)
	DESCRIPTION
		"Implementation need not allow deltas or it may implement
		them and restrict them to higher values."

	OBJECT         expObjectSampleType
	WRITE-SYNTAX   INTEGER { absoluteValue(1) }
	DESCRIPTION
		"Implementation may not allow deltas."

	::= { expressionMIBCompliances 1 }

-- Units of Conformance

expressionResourceGroup OBJECT-GROUP
	OBJECTS {
		expResourceDeltaMinimum,
		expResourceDeltaWildcardInstanceMaximum,
		expResourceDeltaWildcardInstances,
		expResourceDeltaWildcardInstancesHigh,
		expResourceDeltaWildcardInstanceResourceLacks
	}
	STATUS current
	DESCRIPTION
		"Expression definition resource management."
	::= { expressionMIBGroups 1 }

expressionDefinitionGroup OBJECT-GROUP
	OBJECTS {
		expNameLastChange,
		expNameHighestIndex,
		expExpressionIndex,
		expNameStatus,

		expExpressionName,
		expExpression,
		expExpressionValueType,
		expExpressionComment,
		expExpressionDeltaInterval,
		expExpressionPrefix,
		expExpressionErrors,
		expExpressionErrorTime,
		expExpressionErrorIndex,
		expExpressionError,
		expExpressionInstance,
		expExpressionOwner,

		expObjectID,
		expObjectIDWildcard,
		expObjectSampleType,
		expObjectDeltaDiscontinuityID,
		expObjectDiscontinuityIDWildcard,
		expObjectDiscontinuityIDType,
		expObjectConditional,
		expObjectConditionalWildcard,
		expObjectStatus
	}
	STATUS current
	DESCRIPTION
		"Expression definition resource management."
	::= { expressionMIBGroups 2 }

expressionValueGroup OBJECT-GROUP
	OBJECTS {
		expValueCounter32Val,
		expValueUnsigned32Val,
		expValueInteger32Val,
		expValueIpAddressVal,
		expValueOctetStringVal,
		expValueOidVal,
		expValueCounter64Val
	}
	STATUS current
	DESCRIPTION
		"Expression definition resource management."
	::= { expressionMIBGroups 3 }

END
